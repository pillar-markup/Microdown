"
I am the abstract node of the block objects generated by `MicrodownParser`.

The root of the parse tree is an instance of `MicRootBlock`.
I have a set of children, and an uplink to my parent.

See the comment of `MicrodownParser` for an overview of the algorithm used to build such a parse tree.
"
Class {
	#name : 'MicAbstractBlock',
	#superclass : 'MicElement',
	#instVars : [
		'children',
		'parser'
	],
	#category : 'Microdown-Model',
	#package : 'Microdown',
	#tag : 'Model'
}

{ #category : 'public' }
MicAbstractBlock class >> alternateBlockClassFor: line [
	"This hook supports extensions of environments. 
	we get <!slide ... and we do not create an environment but a slideBlock"
	
	^ self
]

{ #category : 'adding' }
MicAbstractBlock >> addChild: childBlock [
	"Add the argument childBlock as child of the receiver. 
	Set the parent backpointer so that childBlock parent is the receiver."
	
	childBlock basicParent: self.
	children add: childBlock
]

{ #category : 'public' }
MicAbstractBlock >> addLineAndReturnNextNode: line [
	"add line to this node. 
	Notice, the action is allowed to create new nodes in the block tree.
	Returns the node to handle next line - typically self."

	self subclassResponsibility.
	^ self
]

{ #category : 'public' }
MicAbstractBlock >> blockExtensionStarterClassFrom: line [
	"return the class of a block which can start with line, or nil if none"

	^ nil
]

{ #category : 'public' }
MicAbstractBlock >> blockStarterClassFrom: line [
	"Return the class of a block which can start with line, or nil if none.
	The principle is the following 
		- first we get a class 
		- then such class as environment are asked since they can act as factory 
		and return other classes. 
		For example <!citation does not return an environment but a MicCitationBlock"

	^ (self parser blockStarterClassFrom: line) ifNotNil: [ :c | c alternateBlockClassFor: line ]
]

{ #category : 'public' }
MicAbstractBlock >> canConsumeLine: line [
	"return if this block can consume line"

	^ self subclassResponsibility 
]

{ #category : 'adding' }
MicAbstractBlock >> children [
	^ children 
]

{ #category : 'adding' }
MicAbstractBlock >> children: aCollection [
 	children := aCollection
]

{ #category : 'public' }
MicAbstractBlock >> closeMe [
	"I'm hook for closing elements. By default do nothing."
	
	^ self
]

{ #category : 'public' }
MicAbstractBlock >> computeNestedLevel [ 

	^ 0
]

{ #category : 'accessing' }
MicAbstractBlock >> indent [
	^ parent indent
]

{ #category : 'initialization' }
MicAbstractBlock >> initialize [
	super initialize. 
	children := OrderedCollection new.
]

{ #category : 'testing' }
MicAbstractBlock >> listItemBlockClass [
	^ MicListItemBlock
]

{ #category : 'public' }
MicAbstractBlock >> nestedLevel [ 
	"Return the nesting level of main blocks. Basically only list increases this."
	
	^ 0
]

{ #category : 'public' }
MicAbstractBlock >> newBlockFor: line parent: parentBlock [
	| newBlockClass |
	newBlockClass := self blockStarterClassFrom: line.
	newBlockClass ifNil: [ ^parentBlock ].
	^ newBlockClass new
		setParser: parser;
		parent: parentBlock;
		addLineAndReturnNextNode: line
]

{ #category : 'private' }
MicAbstractBlock >> parser [
	^ parser 
]

{ #category : 'private' }
MicAbstractBlock >> parserClass [ 
	^ MicrodownParser
]

{ #category : 'adding' }
MicAbstractBlock >> removeChild: childBlock [
	"Remove the childBlock as child of the receiver. 
	Set the parent backpointer so that childBlock parent is the receiver."

	children remove: childBlock
]

{ #category : 'replacement' }
MicAbstractBlock >> replace: aMicElement by: anotherMicElement [ 
	
	self children replaceAll: aMicElement with: anotherMicElement.
	aMicElement basicParent: nil.
	anotherMicElement basicParent: self.
]

{ #category : 'replacement' }
MicAbstractBlock >> replace: aMicElement byCollection: aCollection [ 
	
	children := children copyReplaceAll: {aMicElement} with: aCollection 
]

{ #category : 'replacement' }
MicAbstractBlock >> replaceByAll: aCollection [ 
	self parent replace: self byCollection: aCollection 
]

{ #category : 'private' }
MicAbstractBlock >> setParser: aParser [
	parser := aParser 
]

{ #category : 'accessing' }
MicAbstractBlock >> text [
	| text |
	self flag: #todo.
	"what a terrible idea we concatenate the text of children and store. 
	I could understand that we keep the text of the parser element but then we do not modify it after
	and certainly not change it."
	text := ''.
	children do: [ :each | text := text , each text ].
	^ text
]
